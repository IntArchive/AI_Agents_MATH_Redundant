{
    "Link_API":"https:\/\/api.stackexchange.com\/2.3\/questions\/2190445",
    "Title":"A multiplication algorithm found in a book by Paul Erdős: how does it work?",
    "Score":118,
    "Category":"Chứng minh",
    "Tags":"elementary-number-theory, algorithms",
    "Link":"https:\/\/math.stackexchange.com\/questions\/2190445\/a-multiplication-algorithm-found-in-a-book-by-paul-erd%c5%91s-how-does-it-work",
    "Content":"I am trying to understand the following problem from Erdős and Surányi's Topics in the theory of numbers (Springer), chapter 1 (\"Divisibility, the Fundamental Theorem of Number Theory\"): We can multiply two (positive integer) numbers together in the following way. Write the two numbers down next to each other. Divide the first in half, rounding down to an integer, and write the result below it. Double the second number, writing the result below it. We continue this halving \/ doubling until we are left with $1$ in the first column. Cross out all those numbers in the second column that are opposite an even number and add the remaining numbers in this column together to get the product. Prove that this works. And this is an example, $73 \\cdot 217$ : $(73,217)$ $(36, 434)$ $(18, 868)$ $(9, 1736)$ $(4, 3472)$ $(2, 6944)$ $(1, 13888)$ Then $73 \\cdot 217 = 217+1736+13888 = 15841$ , which is correct. ... and I really cannot visualize the reason why it works. My thoughts so far: We are dividing by $2$ in the left column, so only those values that are odd are coming from a division of a previous even number in the left column, and that means that the previous division by $2$ was \"perfect\", meaning without decimals. I can approximate the value of the product of two natural numbers $p \\cdot q$ if I divide the first number by $2$ continuously until it arrives at $1$ and multiply the second by $2$ at the same time (so the final value of the second one is an approximation of the product). But why do we remove some of them for the final sum? I would like to ask the following questions: How does it work? We are summing the numbers of the second column that are opposite an odd number. Then what does the sum of the numbers that we do not use from the second column represent? This is all probably pretty obvious, but I cannot see the light.",
    "AcceptedAnswer":"This method is often called \"Russian peasant multiplication\". It's often justified by thinking about writing the first number in binary. Here's another way to explain it. At each step, we're replacing a pair $(p,q)$ either by $(\\frac{p}{2}, 2q)$ (when $p$ is even) or by $(\\frac{p-1}{2},2q)$ (when $p$ is odd). In the first case, when $p$ is even, the product of the two numbers doesn't change: $p \\cdot q = \\frac{p}{2} \\cdot 2q$. In the second case, when $p$ is odd, $\\frac{p-1}{2} \\cdot 2q = p \\cdot q - q$. So the product has decreased by $q$, and we should set $q$ aside for later. Eventually, we get to a pair $(1,r)$ whose product is easy to compute: it's just $r$. Because we've kept track of how the product of a pair has changed, we know that the original product is equal to this product, plus all the numbers we've set aside. But we set aside $q$ from the pair $(p,q)$ whenever $p$ is odd. So adding the numbers we set aside to the final number just corresponds to adding up the second number in every pair whose first number is odd. You also wanted to know what the sum of the numbers opposite an even number represents. Given a $p$ and $q$ you want to multiply, choose $k$ such that $2^{k-1} - 1 < p \\le 2^k - 1$. (In other words, $2^k$ is the next power of $2$ after $p$, not including $p$ itself.) Then if we use this algorithm to find $(2^k-1)\\cdot q$, we'll take the same number of steps to get to $1$ on the left-hand side, but all the left-hand numbers along the way are odd. This tells us that the sum of all the right-hand numbers should be the product $(2^k-1) \\cdot q$. Since the sum of all the right-hand numbers opposite an odd left-hand number is $p \\cdot q$, the sum of all the right-hand numbers opposite an even left-hand number is their difference $(2^k-1-p) \\cdot q$.",
    "llm_answer_create_structured_problem":"###BEGIN_OF_FORMAT###\nAssumption: \nThe two numbers are positive integers,\nThe first number is repeatedly halved (integer division),\nThe second number is repeatedly doubled,\nThe process continues until the first number becomes 1,\nOnly the numbers in the second column opposite an odd number in the first column are summed.\nProblem: \nProve that the sum of the remaining numbers in the second column equals the product of the original two numbers.\n###",
    "reasoning_create_structured_problem":"Okay, let me try to figure out how this multiplication method works. So, the problem is about multiplying two numbers using a halving and doubling method, then summing specific terms from the doubling column. The example given is 73 multiplied by 217, and they end up adding 217, 1736, and 13888 to get the correct product. \n\nFirst, I need to understand each step. They start with the two numbers, 73 and 217. Then, they keep halving the left number (discarding any remainder, so it's integer division by 2) and doubling the right number. They continue until the left number is 1. Then, they cross out the numbers in the right column that are opposite an even number in the left column and sum the remaining ones. \n\nSo in the example, the left column has 73, 36, 18, 9, 4, 2, 1. The right column is 217, 434, 868, 1736, 3472, 6944, 13888. The even numbers in the left column are 36, 18, 4, 2. Therefore, they cross out the corresponding right numbers: 434, 868, 3472, 6944. The remaining numbers (opposite the odd numbers 73, 9, 1) are 217, 1736, 13888. Summing these gives the correct product.\n\nHmm, this reminds me of the method of multiplication using binary expansion. Let me think. If we consider the left number being halved each time, it's similar to breaking down the number into powers of two. The doubling on the right is like scaling the number by powers of two. Then, by selecting only the terms where the left number was odd, we're effectively picking the terms that correspond to a '1' in the binary representation of the original left number. \n\nLet me verify that. For example, 73 in binary is 1001001. Let's break that down: 64 + 8 + 1. So, 73 is 2^6 + 2^3 + 2^0. If we multiply 217 by each of these powers of two and sum them up, we get 217*64 + 217*8 + 217*1. Calculating these:\n\n217*64 = 13888\n\n217*8 = 1736\n\n217*1 = 217\n\nAdding them: 13888 + 1736 = 15624; 15624 + 217 = 15841. Which matches the example. \n\nSo, this method is essentially decomposing the left number into a sum of powers of two (binary decomposition) and then summing the corresponding scaled versions of the right number. Each time the left number is odd, it means that there's a power of two component in its binary representation. Therefore, the doubling of the right number corresponds to multiplying by increasing powers of two, and the selection of the terms where the left was odd corresponds to selecting the necessary powers of two to sum up to the original left number. \n\nBut how does the process of halving and doubling lead to this? Let's think step by step. Starting with 73 and 217. Halving 73 gives 36 (since 73 divided by 2 is 36.5, but we take the floor). Doubling 217 gives 434. Then 36 is even, so we cross out 434. Next, halve 36 to get 18, double 434 to 868. 18 is even, cross out 868. Halve 18 to get 9, double 868 to 1736. 9 is odd, so keep 1736. Halve 9 to 4 (since 9\/2 is 4.5, floor is 4), double 1736 to 3472. 4 is even, cross out 3472. Halve 4 to 2, double 3472 to 6944. 2 is even, cross out 6944. Halve 2 to 1, double 6944 to 13888. 1 is odd, keep 13888. Then sum 217 + 1736 + 13888.\n\nSo each time the left number is odd, we keep the corresponding right number. Each time it's even, we cross it out. This seems to correspond to the binary digits of the original left number (73). Let's see:\n\n73 in binary is 1001001. Reading the binary digits from least significant bit to most, the bits are 1 (2^0), 0 (2^1), 0 (2^2), 1 (2^3), 0 (2^4), 0 (2^5), 1 (2^6). The positions where the bits are 1 correspond to the powers 2^0, 2^3, 2^6. \n\nBut in the process of halving, each step reduces the exponent by 1. So starting with 73, which is odd (bit 0), then 36 is even (bit 1 is 0), 18 is even (bit 2 is 0), 9 is odd (bit 3 is 1), etc. So each time we have an odd number in the left column, that indicates a '1' in the binary representation at that position. Therefore, keeping those terms is equivalent to summing 217*(2^0) + 217*(2^3) + 217*(2^6), which is exactly 217*(1 + 8 + 64) = 217*73.\n\nSo the method is essentially a way to perform binary multiplication by decomposing one of the numbers (the left one) into its binary components and then summing the appropriately shifted versions of the other number (the right one). The halving process reveals the binary digits (via the parity), and the doubling process shifts the number left (multiplies by 2 each time). By keeping track of the numbers in the right column when the left is odd, we're effectively selecting the terms where there's a '1' in the binary expansion of the original left number. Therefore, the sum of these terms gives the product of the two original numbers.\n\nBut to formally prove this, we need to show that the algorithm correctly computes the product by connecting it to the binary representation. Let's try to structure the proof.\n\nLet’s denote the two numbers as a and b. The algorithm processes a by repeatedly dividing by 2 (discarding remainders) and processes b by doubling. At each step, if the current a is odd, we add the current b to the result. The final sum is the product a*b.\n\nTo prove this works, we can use induction. Suppose after k steps, the remaining a is a_k, and the accumulated sum S_k. The invariant should be that S_k + a_k * b_k = a * b, where b_k is the current doubled value. Initially, a_0 = a, b_0 = b, S_0 = 0. Then, at each step, if a_k is odd, we add b_k to S_k, so S_{k+1} = S_k + b_k, and a_{k+1} = floor(a_k \/ 2), b_{k+1} = 2 * b_k. If a_k is even, then S_{k+1} = S_k, and a_{k+1} = a_k \/ 2, b_{k+1} = 2 * b_k. \n\nWe can show by induction that S_k + a_k * b_k = a * b for all steps. \n\nBase case: k=0, S_0 + a_0 * b_0 = 0 + a*b = a*b.\n\nInductive step: Assume S_k + a_k * b_k = a*b. Now, if a_k is odd, then a_k = 2 * m + 1 for some m. Then, a_{k+1} = m, b_{k+1} = 2 * b_k, and S_{k+1} = S_k + b_k. So:\n\nS_{k+1} + a_{k+1} * b_{k+1} = (S_k + b_k) + m * (2 * b_k) = S_k + b_k + 2 * m * b_k = S_k + b_k (1 + 2m) = S_k + b_k * (2m + 1) = S_k + b_k * a_k = a*b by the induction hypothesis.\n\nIf a_k is even, then a_k = 2 * m, so a_{k+1} = m, b_{k+1} = 2 * b_k, and S_{k+1} = S_k. Then:\n\nS_{k+1} + a_{k+1} * b_{k+1} = S_k + m * (2 * b_k) = S_k + 2 * m * b_k = S_k + b_k * (2m) = S_k + b_k * a_k = a*b by induction hypothesis.\n\nTherefore, the invariant holds. When a_k becomes 1, we have S_{n} + 1 * b_{n} = a*b. Then, in the next step, a_{n} = 1 is odd, so we add b_{n} to S_{n}, getting S_{n+1} = S_{n} + b_{n}, and a_{n+1} = 0. Then, S_{n+1} + 0 * b_{n+1} = S_{n+1} = a*b. Thus, the final sum is indeed a*b.\n\nThis proves that the algorithm works. The key idea is maintaining the invariant that the sum plus the current a times current b equals the original product. Each step preserves this invariant, whether a is even or odd. When a reaches 0, the sum is the product.\n\nSo, the problem is asking to prove that this halving\/doubling method, by summing the right column entries opposite odd left numbers, correctly computes the product of the two original numbers. The assumptions would involve the specific steps of the algorithm: starting with two positive integers, halving the left and doubling the right until the left is 1, then summing the right entries where the left was odd. The problem is to prove that this sum equals the product.",
    "Original_Problem":"Assumption: \nThe two numbers are positive integers,\nThe first number is repeatedly halved (integer division),\nThe second number is repeatedly doubled,\nThe process continues until the first number becomes 1,\nOnly the numbers in the second column opposite an odd number in the first column are summed.\nProblem: \nProve that the sum of the remaining numbers in the second column equals the product of the original two numbers.",
    "Proof_problem":"Yes",
    "Redundant_assumption":"$2^{k-1} - 1 < p \\le 2^k - 1$",
    "Problem_with_redundant_assumption":"Assumption:\nAssumption 1: The two numbers are positive integers,\nAssumption 2: The first number is repeatedly halved (integer division),\nAssumption 3: The second number is repeatedly doubled,\nAssumption 4: The process continues until the first number becomes 1,\nAssumption 5: Only the numbers in the second column opposite an odd number in the first column are summed.\nAssumption 6: $2^{k-1} - 1 < p \\le 2^k - 1$\nProblem: \nProve that the sum of the remaining numbers in the second column equals the product of the original two numbers.",
    "judge":"```json\n{\n  \"answer_to_Q1\": \"yes\",\n  \"assumptions\": [\"The two numbers are positive integers\", \"The first number is repeatedly halved (integer division)\", \"The second number is repeatedly doubled\", \"The process continues until the first number becomes 1\", \"Only the numbers in the second column opposite an odd number in the first column are summed\", \"$2^{k-1} - 1 < p \\\\le 2^k - 1$\"],\n  \"redundant_assumption\": \"$2^{k-1} - 1 < p \\\\le 2^k - 1$\",\n  \"new_problem\": \"Prove that the sum of the remaining numbers in the second column equals the product of the original two numbers (without the constraint on p)\",\n  \"solution_for_new_problem\": \"The algorithm is Russian peasant multiplication. Proof by induction: Base case p=1: sum = q = 1×q. Inductive step: If p is even (p=2m), algorithm continues with m and 2q, sum = m×(2q) = 2mq = p×q. If p is odd (p=2m+1), algorithm adds q then continues with m and 2q, sum = q + m×(2q) = (2m+1)q = p×q. Therefore, the algorithm correctly computes p×q for any positive integers p and q.\"\n}\n```",
    "proof strategy planner":"",
    "mathematician and proof writer":"",
    "final reviewer":"Proof: True\nproof:\nProblem:\nLet p and q be two positive integers. An algorithm is defined as follows:\n1. Create two columns, the first starting with p, the second with q.\n2. Repeatedly perform the following steps until the number in the first column is 1:\n   a. Halve the number in the first column (using integer division).\n   b. Double the number in the second column.\n3. Sum all the numbers in the second column that are in the same row as an odd number in the first column.\nProve that this sum equals the product of the original two numbers, p and q.\n\nSolution:\nThe algorithm described is known as Russian Peasant Multiplication. We can prove its correctness by induction on p. Let S(p, q) be the result of the algorithm.\n\n**Base Case:** p = 1.\nWhen p = 1, the first column is odd, so the corresponding number in the second column, q, is included in the sum. The algorithm then terminates as the first number is 1. The total sum is q. This is equal to the product 1 × q. Thus, the base case holds.\n\n**Inductive Hypothesis:** Assume that for all positive integers k < p, the algorithm correctly computes the product, i.e., S(k, q) = k × q.\n\n**Inductive Step:** We must show that S(p, q) = p × q.\n\n*   **Case 1: p is even.**\n    Let p = 2m for some positive integer m. Since p is even, the current number q in the second column is not added to the sum. The algorithm proceeds with the next pair of numbers: p' = p \/ 2 = m and q' = q × 2. The result is determined by the rest of the computation, which is S(m, 2q).\n    Since m < p, we can apply the inductive hypothesis:\n    S(p, q) = S(m, 2q) = m × (2q) = (2m)q = p × q.\n\n*   **Case 2: p is odd.**\n    Let p = 2m + 1 for some non-negative integer m. Since p is odd, the current number q in the second column is added to the sum. The algorithm proceeds with the next pair of numbers: p' = (2m + 1) \/\/ 2 = m and q' = q × 2. The final result is q plus the result from the rest of the computation, S(m, 2q).\n    Since m < p, we can apply the inductive hypothesis:\n    S(p, q) = q + S(m, 2q) = q + (m × (2q)) = q + 2mq = (1 + 2m)q = p × q.\n\nIn both cases, the algorithm correctly computes p × q. By the principle of strong induction, the algorithm is correct for all positive integers p.\n\nfinal:\nProblem:\nLet p and q be two positive integers. An algorithm is defined as follows:\n1. Create two columns, the first starting with p, the second with q.\n2. Repeatedly perform the following steps until the number in the first column is 1:\n   a. Halve the number in the first column (using integer division).\n   b. Double the number in the second column.\n3. Sum all the numbers in the second column that are in the same row as an odd number in the first column.\nProve that this sum equals the product of the original two numbers, p and q.\n\nSolution:\nThe algorithm described is known as Russian Peasant Multiplication. We can prove its correctness by induction on p. Let S(p, q) be the result of the algorithm.\n\n**Base Case:** p = 1.\nWhen p = 1, the first column is odd, so the corresponding number in the second column, q, is included in the sum. The algorithm then terminates as the first number is 1. The total sum is q. This is equal to the product 1 × q. Thus, the base case holds.\n\n**Inductive Hypothesis:** Assume that for all positive integers k < p, the algorithm correctly computes the product, i.e., S(k, q) = k × q.\n\n**Inductive Step:** We must show that S(p, q) = p × q.\n\n*   **Case 1: p is even.**\n    Let p = 2m for some positive integer m. Since p is even, the current number q in the second column is not added to the sum. The algorithm proceeds with the next pair of numbers: p' = p \/ 2 = m and q' = q × 2. The result is determined by the rest of the computation, which is S(m, 2q).\n    Since m < p, we can apply the inductive hypothesis:\n    S(p, q) = S(m, 2q) = m × (2q) = (2m)q = p × q.\n\n*   **Case 2: p is odd.**\n    Let p = 2m + 1 for some non-negative integer m. Since p is odd, the current number q in the second column is added to the sum. The algorithm proceeds with the next pair of numbers: p' = (2m + 1) \/\/ 2 = m and q' = q × 2. The final result is q plus the result from the rest of the computation, S(m, 2q).\n    Since m < p, we can apply the inductive hypothesis:\n    S(p, q) = q + S(m, 2q) = q + (m × (2q)) = q + 2mq = (1 + 2m)q = p × q.\n\nIn both cases, the algorithm correctly computes p × q. By the principle of strong induction, the algorithm is correct for all positive integers p.",
    "Original_Problem_with_numerical_assumption":"Assumption:\nAssumption 1: The two numbers are positive integers,\nAssumption 2: The first number is repeatedly halved (integer division),\nAssumption 3: The second number is repeatedly doubled,\nAssumption 4: The process continues until the first number becomes 1,\nAssumption 5: Only the numbers in the second column opposite an odd number in the first column are summed.\nProblem: \nProve that the sum of the remaining numbers in the second column equals the product of the original two numbers."
}