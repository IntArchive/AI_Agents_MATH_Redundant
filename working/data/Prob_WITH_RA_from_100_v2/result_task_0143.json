{
    "Link_API":"https:\/\/api.stackexchange.com\/2.3\/questions\/36022",
    "Title":"How do the Catalan numbers turn up here?",
    "Score":58,
    "Category":"Chứng minh",
    "Tags":"combinatorics, algorithms, catalan-numbers",
    "Link":"https:\/\/math.stackexchange.com\/questions\/36022\/how-do-the-catalan-numbers-turn-up-here",
    "Content":"The Catalan numbers have a reputation for turning up everywhere, but the occurrence described below, in the analysis of an (incorrect) algorithm, is still mysterious to me, and I'm curious to find an explanation. For situations where a quadratic-time sorting algorithm is fast enough, I usually use the following: \/\/Given array a[1], ... a[n]\nfor i = 1 to n:\n    for j = i+1 to n:\n        if a[i] > a[j]:\n            swap(a[i],a[j]) It looks like bubble sort, but is closer to selection sort. It is easy to see why it works: in each iteration of the outer loop, a[i] is set to be the smallest element of a[i…n] . In a programming contest many years ago, one of the problems essentially boiled down to sorting: Given a list of distinct values $W_1, W_2, \\dots, W_n$ , find the indices when it is sorted in ascending order. In other words, find the permutation $(S_1, S_2, \\dots, S_n)$ for which $W_{S_1} < W_{S_2} < \\dots < W_{S_n}$ . This is simply a matter of operating on the indices rather than on the array directly, so the correct code would be: \/\/Given arrays S[1], ..., S[n] (initially S[i]=i ∀i) and W[1], ..., W[n]\nfor i = 1 to n:\n    for j = i+1 to n:\n        if W[S[i]] > W[S[j]]:\n            swap(S[i],S[j]) But in the heat of the contest, I instead coded a program that did, incorrectly: for i = 1 to n:\n    for j = i+1 to n:\n        if W[i] > W[j]:\n            swap(S[i],S[j]) I realised the mistake after the contest ended, and later while awaiting the results, with desperate optimism I tried to figure out the odds that for some inputs, my program would accidentally give the right answer anyway. Specifically, I counted the number of permutations of an arbitrary list $W_1, \\dots, W_n$ with distinct values (since only their order matters, not their actual values) for which the incorrect algorithm above gives the correct answer, for each n: n       Number of \"lucky\" permutations\n0       1\n1       1\n2       2\n3       5\n4       14\n5       42\n6       132\n7       429\n8       1430\n9       4862\n10      16796\n11      58786\n12      208012 These are the Catalan numbers! But why? I've tried to prove this occasionally in my free time, but never succeeded. What I've tried: The (pseudo)algorithm can be represented in more formal notation as the product of all inversions in a permutation. That is, we want to prove that the number of permutations $\\sigma \\in S_n$ such that $$\\prod_{i=1}^{n}\\prod_{\\substack{j \\in \\left\\{i+1,i+2,\\ldots,n\\right\\}; \\\\ \\sigma_i > \\sigma_j}}(i,j) = \\sigma^{-1}$$ (with the convention that multiplication is done left to right) is $C_n$ . This change of notation does not make the problem any simpler. I briefly skimmed through Stanley's famous list of Catalan problems , but this does not seem to be (directly) in the list. :-) Some computer experimentation suggests that the lucky permutations are those that avoid the pattern 312, the number of which is apparently the Catalan numbers. But I have no idea how to prove this, and it may not be the best approach...",
    "AcceptedAnswer":"Your suspicions are correct. Let's show that a permutation is lucky iff it avoids the pattern 312. For an injection $W$ from $\\{1,\\ldots,k\\}$ to $\\{n-k+1,\\ldots,n\\}$ , let $N(W)$ denote the result of removing $W(1)$ and increasing all elements below $W(1)$ by $1$ . For example, $N(32514) = N(3524)$ . Lemma 1. If $W$ avoids $312$ then so does $N(W)$ . Proof. Clear since the relative order of elements in $N(W)$ is the same as the corresponding elements in $W$ . Lemma 2. Suppose $W$ avoids $312$ . After running one round of the algorithm, $S(1)$ contains the index of the minimal element in $W$ , and $W \\circ S = N(W)$ . Proof. The lemma is clear if $W(1)$ is the minimal element. Otherwise, since $W$ avoids $312$ , all elements below $W(1)$ form a decreasing sequence $W(1) = W(i_1) > \\cdots > W(i_k)$ . The algorithm puts the minimal one $W(i_k)$ at $S(1)$ , and puts $W(i_t)$ at $W(i_{t+1})$ . Theorem 1. If $W$ avoids $312$ then $W$ is lucky. Proof. Apply Lemma 2 repeatedly. Lemma 1 ensures that the injection always avoids $312$ . For the other direction, we need to be slightly more careful. Lemma 3. If $W$ contains a pattern $312$ in which $3$ doesn't correspond to $W(1)$ then $N(W)$ contains a pattern $312$ . Proof. The pattern survives in $N(W)$ since all relative positions are maintained. Lemma 4. If $W$ doesn't contain a pattern $312$ in which $3$ corresponds to $W(1)$ and $1$ corresponds to the minimum of $W$ then after running one round of the algorithm, $S(1)$ contains the index of the minimal element, and $W \\circ S = N(W)$ . Proof. Follows directly from the proof of Lemma 2. Thus we should expect trouble if there are $i<j$ such that $W(1) > W(j) > W(i)$ . However, if $W(i)$ is not the minimal element, the trouble won't be immediate. List the elements which are smaller than $W(1)$ as $W(t_1),\\ldots,W(t_k)$ , and suppose that $W(t_r) < W(t_{r+1}) > \\cdots > W(t_k)$ . One round of the algorithm puts $t_r$ at the place of $t_{r+1}$ . The following rounds maintain the relative order of the elements in positions $t_{r+1},\\ldots,t_k$ , and so in the final result, the position which should have contained $t_{r+1}$ will contain $t_r$ . Example: $W = 632541$ . The final result is $S = 652134$ , which corresponds to the permutation $143625$ . We can see that $S(1)$ is correct since $W$ satisfies the conditions of Lemma 4. We have $t_r = 3$ and $W(t_r) = 2, W(t_{r+1}) = 5$ . We see that indeed $W(S(5)) = 2$ instead of $5$ . Theorem 2. If $W$ contains $312$ then $W$ is unlucky. Proof. Along the lines of the discussion above.",
    "llm_answer_create_structured_problem":"###BEGIN_OF_FORMAT###\nassumption: \nThe algorithm initializes array $S$ such that $S[i] = i$ for all $i$,\nThe algorithm incorrectly compares $W[i]$ and $W[j]$ instead of $W[S[i]]$ and $W[S[j]]$,\nThe values $W_1, W_2, \\dots, W_n$ are distinct,\nA permutation $\\sigma$ is \"lucky\" if the incorrect algorithm correctly outputs $\\sigma^{-1}$ as the sorted order of $W$.\nproblem:\nProve that the number of \"lucky\" permutations of length $n$ equals the $n$-th Catalan number $C_n$.\n###",
    "reasoning_create_structured_problem":"Okay, let me try to parse this problem and structure it according to the required format. The user is asking why the number of \"lucky\" permutations, which are those where the incorrect sorting algorithm still produces the correct result, corresponds to the Catalan numbers. \n\nFirst, I need to identify all the assumptions. The problem involves an algorithm that's supposed to sort indices based on the values in array W. The incorrect algorithm swaps the indices in S based on comparing W[i] and W[j] instead of W[S[i]] and W[S[j]]. The user noticed that for certain permutations (the lucky ones), this incorrect algorithm still gives the right answer. The count of these permutations for different n matches the Catalan numbers.\n\nSo the assumptions would include the setup of the problem: that the algorithm is incorrect in a specific way, the permutations considered have distinct values (so order matters, not the actual values), and that the task is to count these permutations for each n.\n\nBreaking down the assumptions:\n\n1. The algorithm incorrectly compares W[i] and W[j] instead of W[S[i]] and W[S[j]].\n2. The permutations considered are of a list with distinct values.\n3. The number of such \"lucky\" permutations for each n corresponds to the Catalan numbers.\n4. The problem is to determine why this count equals the nth Catalan number.\n\nWait, but the user has already observed that the count matches Catalan numbers. The actual problem is to explain why that's the case. So the problem statement should be to prove that the number of permutations for which the incorrect algorithm works correctly is the nth Catalan number.\n\nSo the assumptions should list the conditions of the algorithm and the permutations. Let me list each assumption line by line:\n\nAssumption:\n- The algorithm processes an array S with initial values S[i] = i for all i.\n- The algorithm incorrectly compares W[i] and W[j] instead of W[S[i]] and W[S[j]].\n- The list W contains distinct values.\n- A permutation is \"lucky\" if the incorrect algorithm correctly sorts S based on the values in W.\n\nProblem: Prove that the number of \"lucky\" permutations of length n is the nth Catalan number.\n\nI think that covers the key points. Each assumption is a single condition related to the problem setup. The problem is to establish the count of these permutations as Catalan numbers.",
    "Proof_problem":"Yes",
    "Original_Problem":"assumption: \nThe algorithm initializes array $S$ such that $S[i] = i$ for all $i$,\nThe algorithm incorrectly compares $W[i]$ and $W[j]$ instead of $W[S[i]]$ and $W[S[j]]$,\nThe values $W_1, W_2, \\dots, W_n$ are distinct,\nA permutation $\\sigma$ is \"lucky\" if the incorrect algorithm correctly outputs $\\sigma^{-1}$ as the sorted order of $W$.\nproblem:\nProve that the number of \"lucky\" permutations of length $n$ equals the $n$-th Catalan number $C_n$.",
    "Original_Problem_with_numerical_assumption":"Assumption:\nAssumption 1: The algorithm initializes array $S$ such that $S[i] = i$ for all $i$,\nAssumption 2: The algorithm incorrectly compares $W[i]$ and $W[j]$ instead of $W[S[i]]$ and $W[S[j]]$,\nAssumption 3: The values $W_1, W_2, \\dots, W_n$ are distinct,\nAssumption 4: A permutation $\\sigma$ is \"lucky\" if the incorrect algorithm correctly outputs $\\sigma^{-1}$ as the sorted order of $W$.\nProblem:\nProve that the number of \"lucky\" permutations of length $n$ equals the $n$-th Catalan number $C_n$.",
    "Number_of_Assumption":4,
    "Groundtruth_redundant_assumption":"$t_r = 3$",
    "Groundtruth_redundant_assumption_number":5,
    "Problem_with_redundant_assumption":"Assumption:\nAssumption 1: The algorithm initializes array $S$ such that $S[i] = i$ for all $i$,\nAssumption 2: The algorithm incorrectly compares $W[i]$ and $W[j]$ instead of $W[S[i]]$ and $W[S[j]]$,\nAssumption 3: The values $W_1, W_2, \\dots, W_n$ are distinct,\nAssumption 4: A permutation $\\sigma$ is \"lucky\" if the incorrect algorithm correctly outputs $\\sigma^{-1}$ as the sorted order of $W$.\nAssumption 5: $t_r = 3$\nProblem:\nProve that the number of \"lucky\" permutations of length $n$ equals the $n$-th Catalan number $C_n$.",
    "judge":"Assumption:\nAssumption 1: The algorithm initializes array $S$ such that $S[i] = i$ for all $i$\nAssumption 2: The algorithm incorrectly compares $W[i]$ and $W[j]$ instead of $W[S[i]]$ and $W[S[j]]$\nAssumption 3: The values $W_1, W_2, \\dots, W_n$ are distinct\nAssumption 4: A permutation $\\sigma$ is \"lucky\" if the incorrect algorithm correctly outputs $\\sigma^{-1}$ as the sorted order of $W$\nProblem:\nProve that $t_r = 3$",
    "proof strategy planner":"Assumption:\nAssumption 1: The algorithm initializes array $S$ such that $S[i] = i$ for all $i$\nAssumption 2: The algorithm incorrectly compares $W[i]$ and $W[j]$ instead of $W[S[i]]$ and $W[S[j]]$\nAssumption 3: The values $W_1, W_2, \\dots, W_n$ are distinct\nAssumption 4: A permutation $\\sigma$ is \"lucky\" if the incorrect algorithm correctly outputs $\\sigma^{-1}$ as the sorted order of $W$\nProblem:\nProve that $t_r = 3$\nStep 1) Precisely define the buggy algorithm: Initialize S[i]=i. During sorting comparisons, compare W[i] vs W[j] (incorrect) instead of W[S[i]] vs W[S[j]] (correct).\nStep 2) Formalize what it means for algorithm to output σ^{-1} correctly: Given input sequence W in some order determined by σ, the algorithm's output should be the permutation that sorts W, which should equal σ^{-1}.\nStep 3) Analyze algorithm behavior: The bug causes comparisons to be based on original indices rather than current positions in S array.\nStep 4) For the specific case (likely n=3 or parameter r=3), enumerate all permutations of n elements.\nStep 5) For each permutation σ, simulate the buggy algorithm's execution on input W values ordered according to σ.\nStep 6) Check if the algorithm's output equals σ^{-1} (the inverse permutation that would correctly sort W).\nStep 7) Count the number of permutations where this condition holds.\nStep 8) Show that exactly 3 permutations satisfy the condition (for n=3: permutations like 123, 132, 213 or similar pattern).\nStep 9) Provide combinatorial reasoning: The lucky permutations correspond to those where the relative order of W values compensates for the indexing bug, possibly corresponding to stack-sortable permutations or avoiding certain patterns.\nStep 10) Conclude that t_r = 3 for the case under consideration.",
    "mathematician and proof writer":"Assumption:\nAssumption 1: The algorithm initializes array $S$ such that $S[i] = i$ for all $i$\nAssumption 2: The algorithm incorrectly compares $W[i]$ and $W[j]$ instead of $W[S[i]]$ and $W[S[j]]$\nAssumption 3: The values $W_1, W_2, \\dots, W_n$ are distinct\nAssumption 4: A permutation $\\sigma$ is \"lucky\" if the incorrect algorithm correctly outputs $\\sigma^{-1}$ as the sorted order of $W$\nProblem:\nProve that $t_r = 3$\n",
    "final reviewer":"```json\n{\n \"proof_review\": null,\n \"clear_answer\": \"no\",\n \"finished\": \"yes\"\n}\n```",
    "predicted_redundant_assumption":"$t_r = 3$",
    "redundant_assumption_number":5,
    "proof_review":null,
    "clear_answer":"no"
}