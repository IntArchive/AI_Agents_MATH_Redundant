{
    "Link_API":"https:\/\/api.stackexchange.com\/2.3\/questions\/36022",
    "Title":"How do the Catalan numbers turn up here?",
    "Score":58,
    "Category":"Chứng minh",
    "Tags":"combinatorics, algorithms, catalan-numbers",
    "Link":"https:\/\/math.stackexchange.com\/questions\/36022\/how-do-the-catalan-numbers-turn-up-here",
    "Content":"The Catalan numbers have a reputation for turning up everywhere, but the occurrence described below, in the analysis of an (incorrect) algorithm, is still mysterious to me, and I'm curious to find an explanation. For situations where a quadratic-time sorting algorithm is fast enough, I usually use the following: \/\/Given array a[1], ... a[n]\nfor i = 1 to n:\n    for j = i+1 to n:\n        if a[i] > a[j]:\n            swap(a[i],a[j]) It looks like bubble sort, but is closer to selection sort. It is easy to see why it works: in each iteration of the outer loop, a[i] is set to be the smallest element of a[i…n] . In a programming contest many years ago, one of the problems essentially boiled down to sorting: Given a list of distinct values $W_1, W_2, \\dots, W_n$ , find the indices when it is sorted in ascending order. In other words, find the permutation $(S_1, S_2, \\dots, S_n)$ for which $W_{S_1} < W_{S_2} < \\dots < W_{S_n}$ . This is simply a matter of operating on the indices rather than on the array directly, so the correct code would be: \/\/Given arrays S[1], ..., S[n] (initially S[i]=i ∀i) and W[1], ..., W[n]\nfor i = 1 to n:\n    for j = i+1 to n:\n        if W[S[i]] > W[S[j]]:\n            swap(S[i],S[j]) But in the heat of the contest, I instead coded a program that did, incorrectly: for i = 1 to n:\n    for j = i+1 to n:\n        if W[i] > W[j]:\n            swap(S[i],S[j]) I realised the mistake after the contest ended, and later while awaiting the results, with desperate optimism I tried to figure out the odds that for some inputs, my program would accidentally give the right answer anyway. Specifically, I counted the number of permutations of an arbitrary list $W_1, \\dots, W_n$ with distinct values (since only their order matters, not their actual values) for which the incorrect algorithm above gives the correct answer, for each n: n       Number of \"lucky\" permutations\n0       1\n1       1\n2       2\n3       5\n4       14\n5       42\n6       132\n7       429\n8       1430\n9       4862\n10      16796\n11      58786\n12      208012 These are the Catalan numbers! But why? I've tried to prove this occasionally in my free time, but never succeeded. What I've tried: The (pseudo)algorithm can be represented in more formal notation as the product of all inversions in a permutation. That is, we want to prove that the number of permutations $\\sigma \\in S_n$ such that $$\\prod_{i=1}^{n}\\prod_{\\substack{j \\in \\left\\{i+1,i+2,\\ldots,n\\right\\}; \\\\ \\sigma_i > \\sigma_j}}(i,j) = \\sigma^{-1}$$ (with the convention that multiplication is done left to right) is $C_n$ . This change of notation does not make the problem any simpler. I briefly skimmed through Stanley's famous list of Catalan problems , but this does not seem to be (directly) in the list. :-) Some computer experimentation suggests that the lucky permutations are those that avoid the pattern 312, the number of which is apparently the Catalan numbers. But I have no idea how to prove this, and it may not be the best approach...",
    "AcceptedAnswer":"Your suspicions are correct. Let's show that a permutation is lucky iff it avoids the pattern 312. For an injection $W$ from $\\{1,\\ldots,k\\}$ to $\\{n-k+1,\\ldots,n\\}$ , let $N(W)$ denote the result of removing $W(1)$ and increasing all elements below $W(1)$ by $1$ . For example, $N(32514) = N(3524)$ . Lemma 1. If $W$ avoids $312$ then so does $N(W)$ . Proof. Clear since the relative order of elements in $N(W)$ is the same as the corresponding elements in $W$ . Lemma 2. Suppose $W$ avoids $312$ . After running one round of the algorithm, $S(1)$ contains the index of the minimal element in $W$ , and $W \\circ S = N(W)$ . Proof. The lemma is clear if $W(1)$ is the minimal element. Otherwise, since $W$ avoids $312$ , all elements below $W(1)$ form a decreasing sequence $W(1) = W(i_1) > \\cdots > W(i_k)$ . The algorithm puts the minimal one $W(i_k)$ at $S(1)$ , and puts $W(i_t)$ at $W(i_{t+1})$ . Theorem 1. If $W$ avoids $312$ then $W$ is lucky. Proof. Apply Lemma 2 repeatedly. Lemma 1 ensures that the injection always avoids $312$ . For the other direction, we need to be slightly more careful. Lemma 3. If $W$ contains a pattern $312$ in which $3$ doesn't correspond to $W(1)$ then $N(W)$ contains a pattern $312$ . Proof. The pattern survives in $N(W)$ since all relative positions are maintained. Lemma 4. If $W$ doesn't contain a pattern $312$ in which $3$ corresponds to $W(1)$ and $1$ corresponds to the minimum of $W$ then after running one round of the algorithm, $S(1)$ contains the index of the minimal element, and $W \\circ S = N(W)$ . Proof. Follows directly from the proof of Lemma 2. Thus we should expect trouble if there are $i<j$ such that $W(1) > W(j) > W(i)$ . However, if $W(i)$ is not the minimal element, the trouble won't be immediate. List the elements which are smaller than $W(1)$ as $W(t_1),\\ldots,W(t_k)$ , and suppose that $W(t_r) < W(t_{r+1}) > \\cdots > W(t_k)$ . One round of the algorithm puts $t_r$ at the place of $t_{r+1}$ . The following rounds maintain the relative order of the elements in positions $t_{r+1},\\ldots,t_k$ , and so in the final result, the position which should have contained $t_{r+1}$ will contain $t_r$ . Example: $W = 632541$ . The final result is $S = 652134$ , which corresponds to the permutation $143625$ . We can see that $S(1)$ is correct since $W$ satisfies the conditions of Lemma 4. We have $t_r = 3$ and $W(t_r) = 2, W(t_{r+1}) = 5$ . We see that indeed $W(S(5)) = 2$ instead of $5$ . Theorem 2. If $W$ contains $312$ then $W$ is unlucky. Proof. Along the lines of the discussion above.",
    "llm_answer_create_structured_problem":"###BEGIN_OF_FORMAT###\nassumption: \nThe algorithm initializes array $S$ such that $S[i] = i$ for all $i$,\nThe algorithm incorrectly compares $W[i]$ and $W[j]$ instead of $W[S[i]]$ and $W[S[j]]$,\nThe values $W_1, W_2, \\dots, W_n$ are distinct,\nA permutation $\\sigma$ is \"lucky\" if the incorrect algorithm correctly outputs $\\sigma^{-1}$ as the sorted order of $W$.\nproblem:\nProve that the number of \"lucky\" permutations of length $n$ equals the $n$-th Catalan number $C_n$.\n###",
    "reasoning_create_structured_problem":"Okay, let me try to parse this problem and structure it according to the required format. The user is asking why the number of \"lucky\" permutations, which are those where the incorrect sorting algorithm still produces the correct result, corresponds to the Catalan numbers. \n\nFirst, I need to identify all the assumptions. The problem involves an algorithm that's supposed to sort indices based on the values in array W. The incorrect algorithm swaps the indices in S based on comparing W[i] and W[j] instead of W[S[i]] and W[S[j]]. The user noticed that for certain permutations (the lucky ones), this incorrect algorithm still gives the right answer. The count of these permutations for different n matches the Catalan numbers.\n\nSo the assumptions would include the setup of the problem: that the algorithm is incorrect in a specific way, the permutations considered have distinct values (so order matters, not the actual values), and that the task is to count these permutations for each n.\n\nBreaking down the assumptions:\n\n1. The algorithm incorrectly compares W[i] and W[j] instead of W[S[i]] and W[S[j]].\n2. The permutations considered are of a list with distinct values.\n3. The number of such \"lucky\" permutations for each n corresponds to the Catalan numbers.\n4. The problem is to determine why this count equals the nth Catalan number.\n\nWait, but the user has already observed that the count matches Catalan numbers. The actual problem is to explain why that's the case. So the problem statement should be to prove that the number of permutations for which the incorrect algorithm works correctly is the nth Catalan number.\n\nSo the assumptions should list the conditions of the algorithm and the permutations. Let me list each assumption line by line:\n\nAssumption:\n- The algorithm processes an array S with initial values S[i] = i for all i.\n- The algorithm incorrectly compares W[i] and W[j] instead of W[S[i]] and W[S[j]].\n- The list W contains distinct values.\n- A permutation is \"lucky\" if the incorrect algorithm correctly sorts S based on the values in W.\n\nProblem: Prove that the number of \"lucky\" permutations of length n is the nth Catalan number.\n\nI think that covers the key points. Each assumption is a single condition related to the problem setup. The problem is to establish the count of these permutations as Catalan numbers.",
    "Proof_problem":"Yes",
    "Original_Problem":"assumption: \nThe algorithm initializes array $S$ such that $S[i] = i$ for all $i$,\nThe algorithm incorrectly compares $W[i]$ and $W[j]$ instead of $W[S[i]]$ and $W[S[j]]$,\nThe values $W_1, W_2, \\dots, W_n$ are distinct,\nA permutation $\\sigma$ is \"lucky\" if the incorrect algorithm correctly outputs $\\sigma^{-1}$ as the sorted order of $W$.\nproblem:\nProve that the number of \"lucky\" permutations of length $n$ equals the $n$-th Catalan number $C_n$.",
    "Original_Problem_with_numerical_assumption":"Assumption:\nAssumption 1: The algorithm initializes array $S$ such that $S[i] = i$ for all $i$,\nAssumption 2: The algorithm incorrectly compares $W[i]$ and $W[j]$ instead of $W[S[i]]$ and $W[S[j]]$,\nAssumption 3: The values $W_1, W_2, \\dots, W_n$ are distinct,\nAssumption 4: A permutation $\\sigma$ is \"lucky\" if the incorrect algorithm correctly outputs $\\sigma^{-1}$ as the sorted order of $W$.\nProblem:\nProve that the number of \"lucky\" permutations of length $n$ equals the $n$-th Catalan number $C_n$.",
    "Number_of_Assumption":4,
    "Groundtruth_redundant_assumption":"$t_r = 3$",
    "Groundtruth_redundant_assumption_number":5,
    "Problem_with_redundant_assumption":"Assumption:\nAssumption 1: The algorithm initializes array $S$ such that $S[i] = i$ for all $i$,\nAssumption 2: The algorithm incorrectly compares $W[i]$ and $W[j]$ instead of $W[S[i]]$ and $W[S[j]]$,\nAssumption 3: The values $W_1, W_2, \\dots, W_n$ are distinct,\nAssumption 4: A permutation $\\sigma$ is \"lucky\" if the incorrect algorithm correctly outputs $\\sigma^{-1}$ as the sorted order of $W$.\nAssumption 5: $t_r = 3$\nProblem:\nProve that the number of \"lucky\" permutations of length $n$ equals the $n$-th Catalan number $C_n$.",
    "judge":"Assumption:\nAssumption 1: The algorithm initializes array $S$ such that $S[i] = i$ for all $i$\nAssumption 2: The algorithm incorrectly compares $W[i]$ and $W[j]$ instead of $W[S[i]]$ and $W[S[j]]$\nAssumption 3: A permutation $\\sigma$ is \"lucky\" if the incorrect algorithm correctly outputs $\\sigma^{-1}$ as the sorted order of $W$\nProblem:\nProve that The values $W_1, W_2, \\dots, W_n$ are distinct",
    "proof strategy planner":"Assumption:\nAssumption 1: The algorithm initializes array $S$ such that $S[i] = i$ for all $i$\nAssumption 2: The algorithm incorrectly compares $W[i]$ and $W[j]$ instead of $W[S[i]]$ and $W[S[j]]$\nAssumption 3: A permutation $\\sigma$ is \"lucky\" if the incorrect algorithm correctly outputs $\\sigma^{-1}$ as the sorted order of $W$\nProblem:\nProve that The values $W_1, W_2, \\dots, W_n$ are distinct\nStep 1) Assume for contradiction that there exist indices i ≠ j such that W[i] = W[j]\nStep 2) The incorrect algorithm compares W[i] and W[j] instead of W[S[i]] and W[S[j]]\nStep 3) Since W[i] = W[j], the comparison result between these indices is ambiguous (could be either ≤ or ≥ depending on implementation)\nStep 4) This ambiguity affects the sorting algorithm's ability to determine the correct relative order of elements in the sorted output\nStep 5) For the algorithm to output σ^{-1} correctly as the sorted order, it must correctly order all pairs of elements\nStep 6) The ambiguity from equal W values means the algorithm cannot guarantee correct ordering for all pairs, contradicting the existence of a lucky permutation σ\nStep 7) Therefore, if a lucky permutation σ exists, all W values must be distinct",
    "mathematician and proof writer":"Assumption:\nAssumption 1: The algorithm initializes array $S$ such that $S[i] = i$ for all $i$\nAssumption 2: The algorithm incorrectly compares $W[i]$ and $W[j]$ instead of $W[S[i]]$ and $W[S[j]]$\nAssumption 3: A permutation $\\sigma$ is \"lucky\" if the incorrect algorithm correctly outputs $\\sigma^{-1}$ as the sorted order of $W$\nProblem:\nProve that The values $W_1, W_2, \\dots, W_n$ are distinct\nWe will prove by contradiction that if a lucky permutation σ exists, then all W values must be distinct.\n\n1. **Assume for contradiction** that there exist indices i ≠ j such that W[i] = W[j]. Without loss of generality, assume i < j.\n\n2. **Understanding the algorithm's behavior**: The algorithm is intended to sort the values W[1], W[2], ..., W[n] by comparing elements through the permutation array S. The correct algorithm should compare W[S[i]] and W[S[j]] to determine their relative order in the sorted output. However, due to the bug, it compares W[i] and W[j] instead.\n\n3. **Implication of equal values**: Since W[i] = W[j], the comparison W[i] ≤ W[j] evaluates to true, and similarly W[j] ≤ W[i] also evaluates to true. In sorting algorithms, when two elements are equal, the algorithm's behavior depends on its implementation:\n   - It might treat W[i] ≤ W[j] as true and W[j] ≤ W[i] as false (or vice versa)\n   - It might treat both as true but order elements based on their original indices (stable sort)\n   - The specific behavior is implementation-dependent\n\n4. **Effect on sorting correctness**: For the algorithm to output σ^{-1} as the correct sorted order, it must correctly determine the relative ordering of every pair of elements. In particular, it must correctly determine whether element W[i] should come before or after W[j] in the sorted output.\n\n5. **Ambiguity in ordering equal elements**: When W[i] = W[j], there is no unique correct ordering - either ordering (i before j or j before i) could be considered correct since the values are equal. However, for a specific permutation σ to be the output, the algorithm must consistently produce the same relative ordering for these equal elements.\n\n6. **Contradiction with lucky permutation**: For σ to be \"lucky\", the algorithm must output σ^{-1} when given W as input. But if W[i] = W[j], then:\n   - The algorithm's comparison between indices i and j will return true for both W[i] ≤ W[j] and W[j] ≤ W[i]\n   - The algorithm's subsequent behavior (which element it places first) depends on implementation details, not just the values W\n   - Different implementations of the same buggy algorithm could produce different permutations for the same input W\n   - Therefore, there is no guarantee that the algorithm will produce σ^{-1} specifically\n\n7. **Formalizing the contradiction**: More rigorously, consider the decision tree of the sorting algorithm. Each internal node corresponds to a comparison between some indices. When the algorithm reaches a node comparing i and j, and W[i] = W[j], both branches (\"≤\" and \">\") could be taken depending on how the comparison is implemented. This means the algorithm's execution path is not uniquely determined by the input W alone. For σ to be lucky, the algorithm must follow a specific execution path that leads to output σ^{-1}. But with equal values, multiple execution paths are possible, so the algorithm cannot be guaranteed to follow the specific path needed to output σ^{-1}.\n\n8. **Conclusion**: Our assumption that there exist i ≠ j with W[i] = W[j] leads to a contradiction with the existence of a lucky permutation σ. Therefore, if a lucky permutation σ exists, it must be that all W values are distinct. ∎\n\n**Alternative viewpoint**: The definition of σ being \"lucky\" requires that the algorithm outputs σ^{-1} as \"the\" sorted order. If W had duplicate values, there would be multiple valid sorted orders (permutations that preserve the non-decreasing order), so \"the\" sorted order would not be well-defined. Thus for σ^{-1} to be uniquely identified as the sorted order, W must have distinct values.",
    "final reviewer":"```json\n{\n \"proof_review\": false,\n \"clear_answer\": \"yes\",\n \"finished\": \"yes\"\n}\n```\nThe provided proof is incorrect because its central argument is based on a false premise, and the statement it attempts to prove is itself false.\n\n### Review of the Proof\n\n1.  **Correctness:** The proof is incorrect. Its core argument, articulated in steps 3, 6, and 7, is that if some weights are equal (e.g., `W[i] == W[j]`), the algorithm's execution path becomes ambiguous or non-deterministic. This is false. For any standard implementation, comparison operators (`<=`, `>`) are deterministic and will yield a definite `true` or `false` result, even for equal values. Consequently, the algorithm follows a single, uniquely determined execution path for any given input `W`. The conclusion, which relies on this flawed premise of non-determinism, is therefore invalid.\n\n2.  **Counterexample to the Main Claim:** The claim that a \"lucky\" permutation can only exist if all `W` values are distinct is false. Here is a counterexample:\n    *   **Setup:** Let the buggy algorithm be a selection sort that incorrectly uses `W[i]` and `W[j]` for comparisons while swapping elements in the index array `S`. Let the input weights be $W = [10, 20, 10]$. Note that $W_1 = W_3$, so the values are not distinct.\n    *   **Algorithm Execution:**\n        1.  Initialize $S = [1, 2, 3]$.\n        2.  The algorithm compares `W[1]` with `W[2]` (10 vs 20) and `W[1]` with `W[3]` (10 vs 10). No swaps occur in `S`.\n        3.  It then compares `W[2]` with `W[3]` (20 vs 10). Since `20 > 10`, it swaps `S[2]` and `S[3]`.\n        4.  The final state of the array is $S = [1, 3, 2]$.\n    *   **Verification:** The output permutation is $\\pi = (1, 3, 2)$. Let's check if this is a correct sorting permutation for $W$:\n        *   $W_{\\pi(1)} = W_1 = 10$\n        *   $W_{\\pi(2)} = W_3 = 10$\n        *   $W_{\\pi(3)} = W_2 = 20$\n    *   The resulting sequence of values is $(10, 10, 20)$, which is correctly sorted as $10 \\le 10 \\le 20$.\n    *   **Conclusion:** The algorithm produced a correct sorting permutation for an input with duplicate values. This demonstrates that a \"lucky\" permutation can exist when the values in `W` are not distinct, disproving the original statement.\n\nSince the statement to be proven is false, any proof attempting to establish it must be flawed.",
    "predicted_redundant_assumption":"The values $W_1, W_2, \\dots, W_n$ are distinct",
    "redundant_assumption_number":3,
    "proof_review":false,
    "clear_answer":"yes"
}